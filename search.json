[{"title":"Android跨进程","url":"/2022/02/14/跨进程/","content":"## Android跨进程方式\n\n- Bundle\n\n- ContentProvider\n\n- Socket\n\n- Messager\n\n- AIDL\n\n## Bundle\n\n1. Android开发中，Bundle 无处不在，不管是启动Activity、Service或者发送Broadcast,都会用到。Android可以通过设置 android:process 设置Activity 或者Service所在的进程，因此Android在设计Bundle 的时候就支持跨进程\n   \n   ```\n   Uri uri = Uri.parse(\"smsto:10086\");\n   Intent intent = new Intent(Intent.ACTION_SENDTO, uri);\n   Bundle bundle = new Bundle();\n   bundle.putString(\"sms_body\", \"SMS Text\");\n   intent.putExtras(bundle);\n   //  intent.putExtra(\"sms_body\", \"SMS Text\");\n   startActivity(intent);\n   ```\n\n## ContentProvider\n\n1. 通过继承 ContentProvider ,并实现ContentProvider 的增删改查等方法，实现与其他应用共享数据\n\n## 文件共享\n\n1. 通过共享文件，将共享数据写到文件，然后其他程序通过读取文件，就可以实现数据的共享。\n\n## Messenger\n\n1. 服务端定义 Messenger,在 onBind()方法返回\n   \n   ```kotlin\n   class MessengerService : Service() {\n       var serviceHandler = object : Handler(Looper.getMainLooper()) {\n           override fun handleMessage(msg: Message) {\n               super.handleMessage(msg)\n               when (msg.what) {\n                   0x110 -> {\n                       LogUtils.d(\"收到了客户端消息\")\n                       msg.replyTo.send(Message().apply {\n                           what = 0x110\n                       })\n                   }\n               }\n   \n           }\n       }\n       var messenger = Messenger(serviceHandler)\n   \n       override fun onBind(intent: Intent?): IBinder? {\n   \n           return messenger.binder\n       }\n   }\n   ```\n\n2. 客户端绑定服务,发送消息时Message.replyTo 设置成客户端 Messenger\n   \n   ```kotlin\n     var handler = object : Handler(Looper.getMainLooper()) {\n           override fun handleMessage(msg: Message) {\n               super.handleMessage(msg)\n               when (msg.what) {\n                   0x110 -> {\n                       LogUtils.d(\"收到了服务端0x110消息的回复\")\n                   }\n               }\n           }\n       }\n     var clientMessenger = Messenger(handler)\n     var conn = object : ServiceConnection {\n               override fun onServiceConnected(name: ComponentName?, service: IBinder?) {\n                   var messenger = Messenger(service)\n                   messenger.send(Message().apply {\n                       what = 0x110\n                       replyTo = clientMessenger\n                   })\n   \n               }\n   \n               override fun onServiceDisconnected(name: ComponentName?) {\n   \n               }\n           }\n           var intent = Intent().apply {\n               action = \"com.zjp.messengerservice\"\n               setPackage(\"com.zjp.androidacrossprocessesservice\")\n           }\n      var result = bindService(intent, conn, Context.BIND_AUTO_CREATE)\n   ```\n\n3. 服务端收到消息,通过Message.replyTo 给客户端发送消息\n   \n   ```kotlin\n   var serviceHandler = object : Handler(Looper.getMainLooper()) {\n           override fun handleMessage(msg: Message) {\n               super.handleMessage(msg)\n               when (msg.what) {\n                   0x110 -> {\n                       LogUtils.d(\"收到了客户端消息\")\n                       msg.replyTo.send(Message().apply {\n                           what = 0x110\n                       })\n                   }\n               }\n   \n           }\n       }\n   var messenger = Messenger(serviceHandler)\n   ```\n\n## AIDL\n\n1. 创建AIDL文件：\n   \n   > 通过Android Studio File -> New ->AIDL ->AIDL File ,就可以创建一个AIDL文件。然后Rebuild Project ,Android Studio 就会自动在 build -> generated -> buildType -> out 目录下生成对应的 .java文件，里面就包含了后期我们用到的Stub类。\n\n2. 实现Stub 接口：\n   \n   ```java\n   var stub = object : Stub() {\n           override fun basicType(\n               anInt: Int,\n               aLong: Long,\n               aBoolean: Boolean,\n               aFloat: Float,\n               aDouble: Double,\n               aString: String?\n           ): String {\n   \n               return \"this data is from service\"\n           }\n       }\n   ```\n\n3. onBind 方法返回 stub，向客户端公开接口：\n   \n   ```java\n   override fun onBind(intent: Intent?): IBinder? {\n   \n           return stub.asBinder()\n       }\n   ```\n   \n   现在，`binder` 是 `Stub` 类的一个实例（一个 Binder），其定义了服务的远程过程调用 (RPC) 接口。在下一步中，我们会向客户端公开此实例，以便客户端能与服务进行交互。\n   \n   > - 默认情况下，RPC 调用是同步调用。如果您知道服务完成请求的时间不止几毫秒，则不应从 Activity 的**主线程**调用该服务，因为这可能会使应用挂起（Android 可能会显示“Application is Not Responding”对话框）— 通常，您应从客户端内的单独线程调用服务\n   > \n   > - 您引发的任何异常都不会回传给调用方。\n   \n   > AIDL 支持一下数据类型\n   > \n   > - Java基本数据类型 byte char short int long float double boolean\n   > \n   > - String\n   > \n   > - CharSequence\n   > \n   > - List List里面所有数据必须实现 Parcelable\n   > \n   > - Map Map里面所有数据必须实现 Parcelable\n\n4. Copy 服务端 aidl 文件夹到 客服端对应位置,客户端在 onServiceConnected() 回调中YourServiceInterface*.Stub.asInterface(service),以将返回的参数转换成 *YourServiceInterface* 类型。![](https://raw.githubusercontent.com/SkylineVagrancy/cloudimg/master/2022/02/15-11-16-01-screenshot-20220215-111420.png)\n   \n   ```java\n    var conn = object : ServiceConnection {\n               override fun onServiceConnected(name: ComponentName?, service: IBinder?) {\n                   var stub = IMyAidlInterface.Stub.asInterface(service)\n                   var result = stub.basicTypes(1, 1, false, 1.0f, 1.0, \"测试\")\n   \n               }\n   \n               override fun onServiceDisconnected(name: ComponentName?) {\n   \n               }\n    }\n   ```\n\n## 最后\n\n- **文件共享**：适用于 实时性要求不高，并发场景不多的情况，用法简单通用\n\n- **Bundle：** 适用于Android四大组件之间\n\n- **ContentProvider：** 适用于为其他客户端提供数据，不涉及双向通信\n\n- **AIDL：** 适用于大量复杂数据，有实时双向数据通讯\n\n- **Messenger：** AIDL的简化版本，适用于数据简单，数据交换不是那么频繁\n","tags":["Android"]},{"title":"Hello World","url":"/2022/01/19/hello-world/","content":"\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n```bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n```bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n```bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n```bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"},{"title":"WebSocket报文","url":"/2021/12/15/Websocket 连接过程报文/","content":"# Websocket 连接过程\n\n## 客户端请求报文\n\n    GET / HTTP/1.1\n    Upgrade: websocket\n    Connection: Upgrade\n    Host: example.com\n    Origin: http://example.com\n    Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==\n    Sec-WebSocket-Version: 13 \n\n### 与传统 HTTP 报文不同的地方：\n\n    Upgrade: websocket\n    Connection: Upgrade \n\n这两行表示发起的是 WebSocket 协议。\n\n    Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==\n    Sec-WebSocket-Version: 13\n\nSec-WebSocket-Key 是由浏览器随机生成的，提供基本的防护，防止恶意或者无意的连接。\n\n## 服务端响应报文 Header\n\n首先我们来看看服务端的响应报文：\n\n    HTTP/1.1 101 Switching Protocols\n    Upgrade: websocket\n    Connection: Upgrade\n    Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=\n    Sec-WebSocket-Protocol: chat \n\n1. 首先，101 状态码表示服务器已经理解了客户端的请求，并将通过 Upgrade 消息头通知客户端采用不同的协议来完成这个请求；\n2. 然后， Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key；\n3. 最后， Sec-WebSocket-Protocol 则是表示最终使用的协议。\n\n### Sec-WebSocket-Accept 的计算方法：\n\n1. 将 **Sec-WebSocket-Key** 跟 **258EAFA5-E914-47DA-95CA-C5AB0DC85B11** 拼接\n2. 通过 SHA1 计算出摘要，并转成 base64 字符串。\n","tags":["WebSocket"]},{"title":"Ubuntu下载Android AOSP源码","url":"/2021/10/20/AOSP源码下载/","content":"\n\n由于Android源码过于庞大，普通的代码管理方式不太适用，谷歌就开发了repo工具，专门用于管理Android源码。repo，其实是谷歌使用Python 对Git封装的一个工具而已，本质还是Git，所以我们首先要安装Git和Python。\n\n## 下载repo工具\n\n### 安装Git并设置邮箱和用户名\n\n```bash\nsudo apt-get install git\ngit config --global user.email “usergmail@gmail.com”\ngit config --global user.name “username”\n```\n\n### 安装Python\n\n```bash\nsudo apt-get install python\n```\n\n### 安装curl库\n\n```bash\nsudo apt-get install curl\n```\n\n### 下载repo并设置权限\n\n```bash\nmkdir ~/bin\nPATH=~/bin:$PATH\ncurl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\n#curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo > ~/bin/repo  #国内源，无需翻墙\nchmod a+x ~/bin/repo  #设置权限\n```\n\n## 下载源码\n\n```bash\nmkdir aosp\ncd aosp\n```\n\n### 初始化指定版本\n\n```bash\nrepo init -u https://android.googlesource.com/platform/manifest -b android-9.0.0_r1\n```\n\n> Android版本号查询：[Android 所有版本号](https://android.googlesource.com/platform/manifest/+refs)\n\n如果网络不能翻墙，建议使用清华镜像源[清华源镜像](https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/) 。如果知识阅读，建议使用清华源，如果想编译并在虚拟机上运行，建议翻墙下载谷歌AOSP。\n\n### 下载源码\n\n在初始好了指定版本之后，执行下面的命令就会自动下载源码，我们就只需要静静的等待下载完成。\n\n```bash\nrepo sync\n```\n\n![screenshot-20220114-163417.png](https://raw.githubusercontent.com/SkylineVagrancy/cloudimg/master/2022/01/14-16-34-35-screenshot-20220114-163417.png)\n\n\n\n**下载完成后大概100G左右，但是实际下载过程中会产生很多零时文件，最好预留200G的硬盘空间**\n","tags":["Android"]},{"title":"MarkDown速记","url":"/2021/10/10/markdown/","content":"\n最近准备弄个自己的博客，记录整理一下自己的学习过程。MarkDown作为一种标记语言，简单易上手，而且比较流行的博客都对MarkDown有很好的支持，所以记录一下MarkDown的简单用户，方便在以后的学习中，能刚快的上手。\n\n# 设置头部\n\n```bash\n# Header 1\n## Header 2\n### Header 3\n#### Header 4\n##### Header 5\n###### Header 6\n```\n\n<font color=#ff0000 size=3>效果</font>\n\n## Header 2\n\n### Header 3\n\n#### Header 4\n\n##### Header 5\n\n###### Header 6\n\n# 无序列表（<font color=#ff0000 size=3>注意缩进</font>）\n\n```bash\n*  第一列\n * 第二列\n * 第三列\n  * 第四列\n```\n\n<font color=#ff0000 size=3>效果</font>\n\n* 第一列\n* 第二列\n* 第三列\n  * 第四列\n\n# 有序列表\n\n```\n1. 第一列\n2. 第二列\n3. 第三列\n```\n\n### <font color=#ff0000 size=3>效果</font>\n\n1. 第一列\n2. 第二列\n3. 第三列\n4. 第四列\n\n# 引用\n\n```\n> 第一列\n> 第二列\n> 第三列\n```\n\n### <font color=#ff0000 size=3>引用效果</font>\n\n> 第一列    \n> 第二列    \n> 第三列    \n\n# 嵌套列表\n\n```\n- 列表1\n    + 列表2\n    + 列表3\n        + 列表8\n- 列表4\n    +  列表5\n    +  列表6\n```\n\n### <font color=#ff0000 size=3>嵌套列表效果</font>\n\n- 列表1\n  + 列表2\n  + 列表3\n    + 列表8\n- 列表4\n  + 列表5\n  + 列表6\n\n# 文字链接\n\n```\n[百度一下](https://www.baidu.com \"百度一下\")\n```\n\n### <font color=#ff0000 size=3>文字链接效果</font>\n\n[百度一下](https://www.baidu.com \"百度一下\")\n\n> 前面的百度一下表示展示文字    \n> 后面的百度一下指当鼠标在文字上面的时候显示的内容 \n\n# 图片链接\n\n```\n![测试](http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png \"GitHub Mark\")\n```\n\n### <font color=#ff0000 size=3>图片链接效果</font>\n\n![测试](http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png \"GitHub Mark\")\n\n> 前面的测试指图片的名称  \n> 后面的github mark指鼠标放在图片上展示的内容\n\n# 自动链接\n\n```\n<854350705@qq.com>\n<https:www.baidu.com>\n```\n\n### <font color=#ff0000 size=3>自动链接效果</font>\n\n<854350705@qq.com>    \n<https:www.baidu.com>\n\n# 代码\n\n```\n用``` ```包裹\n或者每行文字4个空格或者1个TAB\n```\n\n### <font color=#ff0000 size=3>代码效果</font>\n\n```java\nString a=\"a\";\nString b = \"b\";\npriintln(a+b);\n```\n\n    String a=\"a\";\n    String a=\"a\";\n    String a=\"a\";\n\n#注释\n\n```\n<!-- 注释 -->\n```\n\n<!-- 注释 -->\n\n# 转义字符\n\n```\n\\\\ 反斜杠\n\\` 反引号\n\\* 星号\n\\_ 下划线\n\\{\\} 大括号\n\\[\\] 中括号\n\\(\\) 小括号\n\\# 井号\n\\+ 加号\n\\- 减号\n\\. 英文句号\n\\! 感叹号\n```\n\n### <font color=#ff0000 size=3>转义效果（每个字符前添加\\）</font>\n\n\\\\ 反斜杠\n\n\\` 反引号\n\n\\* 星号\n\n\\_ 下划线\n\n\\{\\} 大括号\n\n\\[\\] 中括号\n\n\\(\\) 小括号\n\n\\# 井号\n\n\\+ 加号\n\n\\- 减号\n\n\\. 英文句号\n\n\\! 感叹号\n\n# 表格\n\n```\n| 列1        | 列2           |列3 |\n| ------------- |:-------------:| -----:|\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      | centered      |   $12 |\n| zebra stripes | are neat      |    $1 |\n```\n\n### <font color=#ff0000 size=3>表格效果</font>\n\n| 列1            | 列2            | 列3    |\n| ------------- |:-------------:| -----:|\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      | centered      | $12   |\n| zebra stripes | are neat      | $1    |\n\n# 设置字体大小颜色\n\n```\n### <font color=#ff0000 face=\"微软雅黑\" size=12> 表格效果</font>\n```\n\n### <font color=#ff0000 face=\"微软雅黑\" size=3> 设置字体大小颜色效果</font>\n\n# 行内标签\n\n```\n快捷键 `Ctrl + D` 来收藏本页\n```\n\n### <font color=#ff0000 size=3> 行内标签效果</font>\n\n快捷键 `Ctrl + D` 来收藏本页\n\n#html标签\n\n<table>\n    <tr>\n        <th rowspan=\"2\">值班人员</th>\n        <th>星期一</th>\n        <th>星期二</th>\n        <th>星期三</th>\n    </tr>\n    <tr>\n        <td>李强</td>\n        <td>张明</td>\n        <td>王平</td>\n    </tr>\n</table>\n\n#参考式链接\n\n```\n我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3]\n[Leanote 笔记][2]是一个不错的[网站][]。\n[1]:http://www.google.com \"Google\"\n[2]:http://www.leanote.com \"Leanote\"\n[3]:http://http://blog.leanote.com/freewalk \"梵居闹市\"\n[网站]:http://http://blog.leanote.com/freewalk\n```\n\n我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3]\n[Leanote 笔记][2]是一个不错的[网站][]。\n[1]:http://www.google.com \"Google\"\n[2]:http://www.leanote.com \"Leanote\"\n[3]:http://http://blog.leanote.com/freewalk \"梵居闹市\"\n[网站]:http://http://blog.leanote.com/freewalk\n\n#包含段落的列表\n\n> 必须缩进4个空格或者1个TAB\n\n<span id = \"jump\">跳转到这里：</span>\n\n[说明文字](#jump)\n\n# 文字加粗\n\n```\n **加粗内容**\n```\n\n **加粗内容**\n\n# 文字斜体\n\n```\n_斜体_\n```\n\n _斜体_\n","tags":["MarkDown","速记"]},{"title":"Git速记","url":"/2021/08/10/git/","content":"\n### 配置操作\n\n全局配置\n\n`git config --global user.name '您的名字' `\n\n`git config --global user.email '您的邮箱'`\n\n当前仓库配置\n\n`git config --local user.name '您的名字'`\n\n`git config --local user.email '您的邮箱'`\n\n查看Global配置\n`git config --local --list`\n\n删除Global 配置\n\n`git config --unset --global 要删除的配置项`\n\n<!--more-->\n\n删除当前仓库配置\n\n`git config --unset --local 要删除的配置项`\n\n### 本地操作\n\n查看变更\n\n`git status`\n\n将当前目录及其子目录的所有变更保存到暂存区\n\n`git add .`\n\n将仓库内所有变更都加入到暂存区\n\n`git add -A`\n\n将制定文件添加到暂存区\n\n`git add 文件1 文件2 文件3`\n\n比较工作区和暂存区的差异\n\n`git diff`\n\n比较某文件工作区和暂存区的所有差异\n\n`git diff 文件1`\n\n比较暂存区和  **HEAD**  的所有差异\n\n`git diff --cache`\n\n比较某文件暂存区和  **HEAD**  的所有差异\n\n`git diff --cache 文件`\n\n比较某文件工作区和 **HEAD** 的差异\n\n`git diff HEAD 文件`\n\n创建commit\n\n`git commit -m '描述'`\n\n将工作区指定文件恢复和暂存区一致\n\n`git checkout 文件1 文件2 文件3`\n\n将暂存区指定文件恢复和 **HEAD** 一致\n\n`git reset 文件1 文件2 文件3`\n\n将工作区、暂存区所有文件恢复成和 **HEAD** 一致\n\n`git reset --hard`\n\n用 **difftool** 比较任意两个 **commit** 的差异 \n\n`git difftool 提交1 提交2`\n\n查看那些文件没有被git 管控\n\n`git ls-files --others`\n\n将未处理完的变更先保存到 **stash** 中\n\n`git stash`\n\n临时任务处理完继续之前的工作\n\n`pop 不保留 stash`\n\n`apply 保留stash`\n\n`git stash pop`\n\n`git stash apply`\n\n查看所有stash\n\n`git stash list`\n\n取回某次stash 的变更\n\n`git stash pop stash@{数字n}`\n\n修改最后一次的commit 的错误\n\n1. 修改有bug 文件\n2. git add .\n3. git commit –amend –no-edit\n4. git push\n\n### 分支操作\n\n查看当前工作分支和本地分支\n\n`git branch -v`\n\n查看本地和远端分支\n\n`git branch -rv`\n\n切换到指定分支\n\n`git checkout 指定分支`\n\n基于当前分支创建新分支\n\n`git branch 新分支`\n\n基于指定分支创建新分支\n\n`git branch 新分支 指定分支`\n\n基于某个 commit 创建分支\n\n`git branch 新分支 某个commit的id`\n\n创建并切换 到新分支\n\n`git checkout -b 新分支`\n\n安全删除本地某分支\n\n`git branch -d 要删除的分支`\n\n强行删除本地某分支\n\n`git branch -D 要删除的分支`\n\n删除远端 origin 已不存在的本地分支\n\n`git remote prune orgin`\n\n将A分支合并到当前分支\n\n`git merge A分支`\n\n将A分支合并到B分支\n\n`git merge A B`\n\n将当前分支基于B分支坐rebase,以便将B分支合并到当前分支\n\n`git rebase B分支`\n\n将A分支基于B分支坐rebase,以便将B分支合入到A分支\n\n`git rebase B分支 A分支`\n\n### 变更历史\n\n当前分支各个commit 用一行显示\n\n`git log --oneline`\n\n显示就近的N个commit\n\n`git log n`\n\n查看所有涉及某文件的commit\n\n`git log 文件`\n\n某文件最后修改对应的commit 以及作者\n\n`git blame 文件`\n\n### 标签查看\n\n查看所有标签\n\n`git tag`\n\n新建标签\n\n`git tag v1.0`\n\n新建带备注标签\n\n`git tag v1.0 -m '备注'`\n\n给指定的commit 打标签\n\n`git tag 标签 提交ID`\n\n推送一个本地标签\n\n`git push origin 标签`\n\n推送全部未推送的本地标签\n\n`git push origin --tags`\n\n删除一个本地标签\n\n`git tag -d 标签`\n\n删除一个远端标签\n\n`git push origin:refs/tags/标签`\n\n### 远端交互\n\n查看所有远端仓库\n\n`git remote -v`\n\n添加远端仓库\n\n`git remote add origin 远端仓库URL`\n\n删除远端仓库\n\n```java\ngit remote remove 远端仓库名\n```\n\n重命名远端仓库\n\n`git remote rename 旧名称 新名称`\n\n将远端所有分支和标签的变更拉倒本地\n\n`git fetch remote`\n\n把远端分支的变更拉倒本地，且 merge 到本地分支\n\n`git pull origin 分支名`\n\n将本地分支 push 到远端\n\n`git push origin 分支名`\n\n删除远端分支\n\n`git push remote --delete 远端分支`\n\n`git push remote:远端分支名`\n\n![git](https://raw.githubusercontent.com/SkylineVagrancy/cloudimg/master/2022/02/16-11-38-22-git%E9%80%9F%E8%AE%B0.jpeg)\n","tags":["Git"]}]