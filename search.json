[{"title":"管理Manifest文件","url":"/2022/03/07/管理manifest文件/","content":"\n## 合并多个Manifest文件\n\n您的Android 项目里面，可以包含多个moudle，每个moudle都存在一个AndroidManifest文件，但是你最终打包的APK里面，只存在一个AndroidManifest，gradle在打包的时候，会很多多个Manifest 文件到一个文件里面。\n\n清单合并工具通过遵循一些合并启发式方法并遵守您使用特殊 XML 属性定义的合并首选项来合并每个文件中的所有 XML 元素。本页介绍清单合并的工作原理以及如何应用合并首选项来解决合并冲突。\n\n<!--more-->\n\n### 合并优先级\n\n合并工具通过根据每个清单文件的优先级顺序合并所有清单文件，将它们合并到一个文件中。例如，如果您有三个清单文件，则最低优先级的清单会合并到下一个最高优先级的清单中，然后再合并到最高优先级的清单中，如图 1 所示。\n\n<img title=\"\" src=\"https://developer.android.com/studio/images/build/manifest-merger_2x.png\" alt=\"\" data-align=\"inline\">\n\n\n\n\n\nAndroid常见的需要合并的清单文件包括三种类型（优先级由低到高）：\n\n\n\n1. **库项目中的清单文件**\n\n2. **应用模块的主清单文件**\n\n3. **构建变体的清单文件**\n\n\n\n### 冲突合并原则\n\n| 高优先级属性 | 低优先级属性 | 合并后属性                      |     |\n| ------ | ------ | -------------------------- | --- |\n| 没有值    | 没有值    | 没有值                        |     |\n|        | B      | B                          |     |\n| A      | 没有值    | A                          |     |\n|        | A      | A                          |     |\n|        | B      | 冲突，必须添加<mark>冲突合并标记</mark> |     |\n\n某些情况下，合并工具会根据一些规则，避免冲突：\n\n1. `<manifest>` 元素中的属性绝不会合并在一起，只会使用优先级最高的清单中的属性\n\n2. [`<uses-feature>`](https://developer.android.com/guide/topics/manifest/uses-feature-element) 和 [`<uses-library>`](https://developer.android.com/guide/topics/manifest/uses-library-element) 元素中的 `android:required` 属性使用 OR 合并，这样一来，如果发生冲突，系统将应用 `\"true\"` 并始终包含一个清单所需的功能或库\n\n3. [`<uses-sdk>`](https://developer.android.com/guide/topics/manifest/uses-sdk-element) 元素中的属性始终使用优先级较高的清单中的值，但以下情况除外：\n   \n   1. - 如果优先级较低的清单中的 `minSdkVersion` 值较高，那么除非您应用 [`overrideLibrary`](https://developer.android.com/studio/build/manage-manifests#override_wzxhzdk35uses-sdk_for_imported_libraries) 合并规则，否则将会发生错误。\n      - 如果优先级较低的清单中的 `targetSdkVersion` 值较低，合并工具将使用优先级较高的清单中的值，但也会添加所有必要的系统权限，以确保所导入的库继续正常运作（以防遇到较高的 Android 版本具有更多权限限制的情况）。如需详细了解此行为，请参阅有关[隐式系统权限](https://developer.android.com/studio/build/manage-manifests#implicit_system_permissions)的部分。\n\n4. 绝不会在清单之间匹配 `<intent-filter>` 元素。每个该元素都被视为唯一的元素，并添加到合并后的清单中的共同父元素中\n   \n   \n\n### 合并标记\n\n合并标记又分为两类：**节点标记** 和 **属性标记**\n\n#### **节点标记有：**\n\n- **tools:node=\"merge\"**：没有冲突情况下，默认的冲突解决标记\n  \n  **低优先级清单**\n  \n  ```xml\n  <activity android:name=\"com.example.ActivityOne\"\n   android:windowSoftInputMode=\"stateUnchanged\">\n   <intent-filter> <action android:name=\"android.intent.action.SEND\" />\n   <category android:name=\"android.intent.category.DEFAULT\" /> </intent-filter>\n  </activity>\n  ```\n  \n  **高优先级清单**\n  \n  ```xml\n  <activity android:name=\"com.example.ActivityOne\"\n      android:screenOrientation=\"portrait\"\n      tools:node=\"merge\">\n  </activity>\n  ```\n  \n  **合并后清单**\n  \n  ```xml\n  <activity android:name=\"com.example.ActivityOne\"\n      android:screenOrientation=\"portrait\"\n      android:windowSoftInputMode=\"stateUnchanged\">\n      <intent-filter>\n          <action android:name=\"android.intent.action.SEND\" />\n          <category android:name=\"android.intent.category.DEFAULT\" />\n      </intent-filter>\n  </activity>\n  ```\n\n- **tools:node=\"merge-only-attributes\"**：仅合并此标记中的属性，不合并嵌套元素。\n  \n  **低优先级清单：**\n  \n  ```xml\n  <activity android:name=\"com.example.ActivityOne\"\n      android:windowSoftInputMode=\"stateUnchanged\">\n      <intent-filter>\n          <action android:name=\"android.intent.action.SEND\" />\n          <data android:type=\"image/*\" />\n          <category android:name=\"android.intent.category.DEFAULT\" />\n      </intent-filter>\n  </activity>\n  ```\n  \n  **高优先级清单：**\n  \n  ```xml\n  <activity android:name=\"com.example.ActivityOne\"\n      android:screenOrientation=\"portrait\"\n      tools:node=\"merge-only-attributes\">\n  </activity>\n  ```\n  \n  **合并后的清单结果：**\n  \n  ```xml\n  <activity android:name=\"com.example.ActivityOne\"\n      android:screenOrientation=\"portrait\"\n      android:windowSoftInputMode=\"stateUnchanged\">\n  </activity>\n  ```\n\n- **tools:node=\"remove\"**\n  \n  从合并后的清单中移除此元素。虽然您似乎只需要删除此元素即可，但如果您发现合并后的清单中有不需要的元素，而且该元素是由不受您控制的优先级较低的清单文件（如导入的库）提供的，则必须使用此属性。\n  \n  \n  \n  **低优先级清单：**\n  \n  ```xml\n  <activity-alias android:name=\"com.example.alias\">\n    <meta-data android:name=\"cow\"\n        android:value=\"@string/moo\"/>\n    <meta-data android:name=\"duck\"\n        android:value=\"@string/quack\"/>\n  </activity-alias>\n  ```\n  \n  **高优先级清单：**\n  \n  ```xml\n  <activity-alias android:name=\"com.example.alias\">\n    <meta-data android:name=\"cow\"\n        tools:node=\"remove\"/>\n  </activity-alias>\n  ```\n  \n  **合并后的清单结果：**\n  \n  ```xml\n  <activity-alias android:name=\"com.example.alias\">\n    <meta-data android:name=\"duck\"\n        android:value=\"@string/quack\"/>\n  </activity-alias>\n  ```\n\n- **tools:node=\"removeAll\"**\n  \n  与 `tools:node=\"remove\"` 类似，但它会移除与此元素类型匹配的所有元素（同一父元素内）\n  \n  **低优先级清单：**\n  \n  ```xml\n  <activity-alias android:name=\"com.example.alias\">\n    <meta-data android:name=\"cow\"\n        android:value=\"@string/moo\"/>\n    <meta-data android:name=\"duck\"\n        android:value=\"@string/quack\"/>\n  </activity-alias>\n  ```\n  \n  **高优先级清单：**\n  \n  ```xml\n  <activity-alias android:name=\"com.example.alias\">\n    <meta-data tools:node=\"removeAll\"/>\n  </activity-alias>\n  ```\n  \n  **合并后的清单结果：**\n  \n  ```xml\n  <activity-alias android:name=\"com.example.alias\">\n  </activity-alias>\n  ```\n\n- **tools:node=\"replace\"**\n  \n  完全替换优先级较低的元素。也就是说，如果优先级较低的清单中有匹配的元素，会将其忽略并完全按照此元素在此清单中显示的样子使用它\n  \n  **低优先级清单：**\n  \n  ```xml\n  <activity-alias android:name=\"com.example.alias\">\n    <meta-data android:name=\"cow\"\n        android:value=\"@string/moo\"/>\n    <meta-data android:name=\"duck\"\n        android:value=\"@string/quack\"/>\n  </activity-alias>\n  ```\n  \n  **高优先级清单：**\n  \n  ```xml\n  <activity-alias android:name=\"com.example.alias\"\n      tools:node=\"replace\">\n    <meta-data android:name=\"fox\"\n        android:value=\"@string/dingeringeding\"/>\n  </activity-alias>\n  ```\n  \n  **合并后的清单结果：**\n  \n  ```xml\n  <activity-alias android:name=\"com.example.alias\">\n    <meta-data android:name=\"fox\"\n        android:value=\"@string/dingeringeding\"/>\n  </activity-alias>\n  ```\n\n- **tools:node=\"strict\"**\n  \n  每当此元素在优先级较低的清单中与在优先级较高的清单中不完全匹配时，都会导致构建失败（除非已通过其他合并规则标记解决）。这会替换[合并冲突启发式算法](https://developer.android.com/studio/build/manage-manifests#merge_conflict_heuristics)。例如，如果优先级较低的清单只是包含一个额外的属性，构建就会失败（尽管默认行为是将该额外属性添加到合并后的清单中）\n  \n  **低优先级清单：**\n  \n  ```xml\n  <activity android:name=\"com.example.ActivityOne\"\n      android:windowSoftInputMode=\"stateUnchanged\">\n      <intent-filter>\n          <action android:name=\"android.intent.action.SEND\" />\n          <category android:name=\"android.intent.category.DEFAULT\" />\n      </intent-filter>\n  </activity>\n  ```\n  \n  **高优先级清单：**\n  \n  ```xml\n  <activity android:name=\"com.example.ActivityOne\"\n      android:screenOrientation=\"portrait\"\n      tools:node=\"strict\">\n  </activity>\n  ```\n  \n  **这会导致清单合并错误**。在严格模式下，这两个清单元素不能有任何不同。因此，您必须应用其他合并规则标记解决这些差异。（通常，这两个元素会正常合并在一起，如上面的 `tools:node=\"merge\"` 示例中所示。）\n\n#### **属性标记分为：**\n\n- **tools:remove=\"attr, ...\"**\n  \n  从合并后的清单中移除指定属性。虽然您似乎只需要删除这些属性即可，但如果优先级较低的清单文件包含这些属性，而您想确保它们不会被纳入合并后的清单，则必须使用此属性。\n  \n  **低优先级清单：**\n  \n  ```xml\n  <activity android:name=\"com.example.ActivityOne\"\n      android:windowSoftInputMode=\"stateUnchanged\">\n  ```\n  \n  **高优先级清单：**\n  \n  ```xml\n  <activity android:name=\"com.example.ActivityOne\"\n      android:screenOrientation=\"portrait\"\n      tools:remove=\"android:windowSoftInputMode\">\n  ```\n  \n  **合并后的清单结果：**\n  \n  ```xml\n  <activity android:name=\"com.example.ActivityOne\"\n      android:screenOrientation=\"portrait\">\n  ```\n\n- **tools:replace=\"attr, ...\"**\n  \n  将优先级较低的清单中的指定属性替换为此清单中的属性\n  \n  **低优先级清单：**\n  \n  ```xml\n  <activity android:name=\"com.example.ActivityOne\"\n      android:theme=\"@oldtheme\"\n      android:exported=\"false\"\n      android:windowSoftInputMode=\"stateUnchanged\">\n  ```\n  \n  **高优先级清单：**\n  \n  ```xml\n  <activity android:name=\"com.example.ActivityOne\"\n      android:theme=\"@newtheme\"\n      android:exported=\"true\"\n      android:screenOrientation=\"portrait\"\n      tools:replace=\"android:theme,android:exported\">\n  ```\n  \n  **合并后的清单结果：**\n  \n  ```xml\n  <activity android:name=\"com.example.ActivityOne\"\n      android:theme=\"@newtheme\"\n      android:exported=\"true\"\n      android:screenOrientation=\"portrait\"\n      android:windowSoftInputMode=\"stateUnchanged\">\n  ```\n\n- **tools:strict=\"attr, ...\"**\n  \n  每当这些属性在优先级较低的清单中与在优先级较高的清单中不完全匹配时，都会导致构建失败。**这是所有属性的默认行为**，但具有特殊行为的属性除外，如[合并冲突启发法](https://developer.android.com/studio/build/manage-manifests#merge_conflict_heuristics)中所述。\n  \n  **低优先级清单：**\n  \n  ```xml\n  <activity android:name=\"com.example.ActivityOne\"\n      android:screenOrientation=\"landscape\">\n  </activity>\n  ```\n  \n  **高优先级清单：**\n  \n  ```xml\n  <activity android:name=\"com.example.ActivityOne\"\n      android:screenOrientation=\"portrait\"\n      tools:strict=\"android:screenOrientation\">\n  </activity>\n  ```\n  \n  \n  这会导致清单合并错误**。您必须应用其他合并规则标记解决冲突。（切记：这是默认行为，因此如果您移除 `tools:strict=\"screenOrientation\"`，上面的示例将具有相同的结果。）**\n\n\n\n    您也可以对一个元素应用多个标记，如下所示：\n\n    **低优先级清单：**\n\n```xml\n<activity android:name=\"com.example.ActivityOne\"\n    android:theme=\"@oldtheme\"\n    android:exported=\"false\"\n    android:allowTaskReparenting=\"true\"\n    android:windowSoftInputMode=\"stateUnchanged\">\n```\n\n    **高优先级清单：**\n\n```xml\n<activity android:name=\"com.example.ActivityOne\"\n    android:theme=\"@newtheme\"\n    android:exported=\"true\"\n    android:screenOrientation=\"portrait\"\n    tools:replace=\"android:theme,android:exported\"\n    tools:remove=\"android:windowSoftInputMode\">\n```\n\n    **合并后的清单结果：**\n\n```xml\n<activity android:name=\"com.example.ActivityOne\"\n    android:theme=\"@newtheme\"\n    android:exported=\"true\"\n    android:allowTaskReparenting=\"true\"\n    android:screenOrientation=\"portrait\">\n```\n\n## 检查合并后的清单文件并查找冲突\n\n甚至在您构建应用之前，就可以预览合并后的清单是什么样子，方法是在 Android Studio 中打开您的 `AndroidManifest.xml` 文件，然后点击编辑器底部的 **Merged Manifest** 标签页。\n\n在“Merged Manifest”视图中，左侧会显示合并后的清单结果，右侧会显示所合并的每个清单文件的相关信息，如图 2 所示。从优先级较低的清单文件中合并的元素在左侧以不同的颜色突出显示。每种颜色的键在右侧的 **Manifest Sources** 下方指定。\n\n![](https://developer.android.com/studio/images/build/manifest-merged-view_2x.png)\n\n属于 build 的一部分但未贡献元素或属性的清单文件列在右侧的 **Other Manifest Files** 下方。\n\n如需查看有关元素来源的信息，只需在左侧点击相应元素，详细信息即会显示在右侧的 **Merging Log** 下方。\n\n如果发生任何冲突，它们将显示在右侧的 **Merging Errors** 下方，并且包含有关如何使用[合并规则标记](https://developer.android.com/studio/build/manage-manifests#merge_rule_markers)解决冲突的建议。错误也会显示在 **Event Log** 窗口（依次选择 **View > Tool Windows > Event Log**）中。\n\n如果您想要查看合并决策树的完整日志，可以在模块的 `build/outputs/logs/` 目录中查找名为 `manifest-merger-buildVariant-report.txt` 的日志文件\n\n## 合并策略\n\n清单合并工具可以在逻辑上将一个清单文件中的每个 XML 元素与另一个文件中的对应元素相匹配。合并工具会使用“匹配键”匹配每个元素，匹配键可以是唯一的属性值（如 `android:name`），也可以是标记本身的自然唯一性（例如，只能有一个 `<supports-screen>` 元素）。如果两个清单具有相同的 XML 元素，则该工具会采用三种合并政策中的一种，将这两个元素合并在一起：\n\n**合并**\n\n        将所有没有冲突的属性组合到同一标记中，并按各自的合并政策合并子元素。如果任何属性相互冲突，则使用[合并规则标记](https://developer.android.com/studio/build/manage-manifests#merge_rule_markers)将它们合并在一起。\n\n**仅合并子元素**\n\n        不组合或合并属性（仅保留优先级最高的清单文件提供的属性），并按各自的合并政策合并子元素。\n\n**保留**\n\n        将元素“按原样”保留，并将其添加到合并后的文件中的共同父元素中。只有在可以接受同一元素有多个声明时，才会采用此政策。\n\n| 元素                       | 合并政策   | 匹配键                                                   |\n| ------------------------ | ------ | ----------------------------------------------------- |\n| `<action>`               | 合并     | `android:name` 属性                                     |\n| `<activity>`             | 合并     | `android:name` 属性                                     |\n| `<application>`          | 合并     | 每个 `<manifest>` 只有一个                                  |\n| `<category>`             | 合并     | `android:name` 属性                                     |\n| `<data>`                 | 合并     | 每个 `<intent-filter>` 只有一个                             |\n| `<grant-uri-permission>` | 合并     | 每个 `<provider>` 只有一个                                  |\n| `<instrumentation>`      | 合并     | `android:name` 属性                                     |\n| `<intent-filter>`        | 保留     | 不匹配；允许父元素内的多个声明                                       |\n| `<manifest>`             | 仅合并子元素 | 每个文件只有一个                                              |\n| `<meta-data>`            | 合并     | `android:name` 属性                                     |\n| `<path-permission>`      | 合并     | 每个 `<provider>` 只有一个                                  |\n| `<permission-group>`     | 合并     | `android:name` 属性                                     |\n| `<permission>`           | 合并     | `android:name` 属性                                     |\n| `<permission-tree>`      | 合并     | `android:name` 属性                                     |\n| `<provider>`             | 合并     | `android:name` 属性                                     |\n| `<receiver>`             | 合并     | `android:name` 属性                                     |\n| `<screen>`               | 合并     | `android:screenSize` 属性                               |\n| `<service>`              | 合并     | `android:name` 属性                                     |\n| `<supports-gl-texture>`  | 合并     | `android:name` 属性                                     |\n| `<supports-screen>`      | 合并     | 每个 `<manifest>` 只有一个                                  |\n| `<uses-configuration>`   | 合并     | 每个 `<manifest>` 只有一个                                  |\n| `<uses-feature>`         | 合并     | `android:name` 属性（如果不存在，则使用 `android:glEsVersion` 属性） |\n| `<uses-library>`         | 合并     | `android:name` 属性                                     |\n| `<uses-permission>`      | 合并     | `android:name` 属性                                     |\n| `<uses-sdk>`             | 合并     | 每个 `<manifest>` 只有一个                                  |\n| 自定义元素                    | 合并     | 不匹配；合并工具并不知晓这些元素，因此它们始终包含在合并后的清单中                     |\n","tags":["Android"]},{"title":"Android常用ADB命令（持续更新）","url":"/2022/03/02/Android常用ADB命令/","content":"\n## 获取程序包名\n\n```cmd\nadb shell pm list packages\n```\n\n```\n$ adb shell pm list packages\npackage:android\npackage:cn.wps.moffice\npackage:com.android.backupconfirm\npackage:com.android.bluetooth\npackage:com.android.browser\npackage:com.android.calculator2\npackage:com.android.camera\npackage:com.android.certinstaller\npackage:com.android.contacts\n```\n\n## 找到apk的位置\n\n```\nadb shell pm path com.tence01.mm\n```\n\n```\n$ adb shell pm path com.tence01.mm\npackage:/data/app/com.tence01.mm-1.apk\n```\n\n## 取出apk\n\n```\nadb pull /data/app/com.tence01.mm-1.apk ~/apks\n```\n\n```\n$ adb pull /data/app/com.tence01.mm-1.apk ~/apks\n2407 KB/s (25567735 bytes in 10.370s)\n```\n\n## 启动Activity\n\n```shell\nadb shell am start -n 包名/包名.ActivityName\n```\n\n<!--more-->\n\n## 关闭应用\n\n```shell\nadb shell am force-stop 包名\n```\n\n## 启动Service\n\n```shell\nadb shell am startservice -n 包名/包名.ServiceName\n```\n\n## 拨打电话\n\n```shell\nadb shell am start -a android.intent.action.CALL -d tel:10086\n```\n\n## 打开网页\n\n```shell\nadb shell am start -a android.intent.action.VIEW -d http://www.baidu.com\n```\n\n## 卸载应用\n\n```shell\nadb uninstall 包名\n```\n\n## 发送广播\n\n```shell\nadb shellam broadcast -a android.net.conn.CONNECTIVITY_CHANGE\n//发送一个网络变化的广播\n```\n\n## 卸载重新安装\n\n```shell\nadb shell install -r apk路径\n```\n\n## 查看指定包名进程\n\n```shell\nadb shell ps | grep \"com.tencent.qq\"\n```\n\n## 强杀进程\n\n### 强杀指定PID\n\n```shell\nadb shell kill pid\n```\n\n### 强杀指定包名\n\n```shell\nadb shell am force-stop com.taobao.taobao\n```\n\n## 查看建立连接的终端\n\n```shell\nadb devices\n```\n\n## 重新加载磁盘\n\n```shell\nadb remount\n```\n\n## 重启\n\n```shell\nadb reboot\n```\n\n## 发送文件到设备\n\n```shell\nadb push /Users/test.apk /sdcard\n```\n\n## 导出文件到电脑\n\n```shell\nadb pull /sdcard/demo.mp4 /Users\n```\n\n## 打印日志\n\n```shell\nadb logcat\nadb logcat *:V\nadb logcat *:D\n```\n\n## 清空缓存\n\n```shell\nadb shell pm clear\n```\n\n## Ping\n\n```shell\n adb shell ping www.baidu.com\n```\n\n## 截图\n\n```shell\nadb shell screencap /sdcard/screen.png\n```\n\n## 录屏\n\n```shell\nadb shell screenrecord /sdcard/demo.mp4 //3分钟自动结束，或者Ctrl+C\n```\n\n## 设备信息\n\n```shell\nadb shell getprop \nadb shell getprop ro.build.version.sdk\n```\n\n## 查看当前界面Activity\n\n```shell\nadb shell \"dumpsys activity top | grep ACTIVITY | tail -n 1\"\n```\n\n## 查看当前界面Fragment\n\n```shell\nadb shell \"dumpsys activity top | grep '#[0-9]: ' | tail -n 1\"\n```\n","tags":["Android"]},{"title":"Android跨进程","url":"/2022/02/14/跨进程/","content":"\n## Android跨进程方式\n\n- Bundle\n\n- ContentProvider\n\n- Socket\n\n- Messager\n\n- AIDL\n\n## Bundle\n\n1. Android开发中，Bundle 无处不在，不管是启动Activity、Service或者发送Broadcast,都会用到。Android可以通过设置 android:process 设置Activity 或者Service所在的进程，因此Android在设计Bundle 的时候就支持跨进程\n   \n   ```\n   Uri uri = Uri.parse(\"smsto:10086\");\n   Intent intent = new Intent(Intent.ACTION_SENDTO, uri);\n   Bundle bundle = new Bundle();\n   bundle.putString(\"sms_body\", \"SMS Text\");\n   intent.putExtras(bundle);\n   //  intent.putExtra(\"sms_body\", \"SMS Text\");\n   startActivity(intent);\n   ```\n\n<!--more-->\n\n## ContentProvider\n\n1. 通过继承 ContentProvider ,并实现ContentProvider 的增删改查等方法，实现与其他应用共享数据\n\n## 文件共享\n\n1. 通过共享文件，将共享数据写到文件，然后其他程序通过读取文件，就可以实现数据的共享。\n\n## Messenger\n\n1. 服务端定义 Messenger,在 onBind()方法返回\n   \n   ```kotlin\n   class MessengerService : Service() {\n       var serviceHandler = object : Handler(Looper.getMainLooper()) {\n           override fun handleMessage(msg: Message) {\n               super.handleMessage(msg)\n               when (msg.what) {\n                   0x110 -> {\n                       LogUtils.d(\"收到了客户端消息\")\n                       msg.replyTo.send(Message().apply {\n                           what = 0x110\n                       })\n                   }\n               }\n   \n           }\n       }\n       var messenger = Messenger(serviceHandler)\n   \n       override fun onBind(intent: Intent?): IBinder? {\n   \n           return messenger.binder\n       }\n   }\n   ```\n\n2. 客户端绑定服务,发送消息时Message.replyTo 设置成客户端 Messenger\n   \n   ```kotlin\n     var handler = object : Handler(Looper.getMainLooper()) {\n           override fun handleMessage(msg: Message) {\n               super.handleMessage(msg)\n               when (msg.what) {\n                   0x110 -> {\n                       LogUtils.d(\"收到了服务端0x110消息的回复\")\n                   }\n               }\n           }\n       }\n     var clientMessenger = Messenger(handler)\n     var conn = object : ServiceConnection {\n               override fun onServiceConnected(name: ComponentName?, service: IBinder?) {\n                   var messenger = Messenger(service)\n                   messenger.send(Message().apply {\n                       what = 0x110\n                       replyTo = clientMessenger\n                   })\n   \n               }\n   \n               override fun onServiceDisconnected(name: ComponentName?) {\n   \n               }\n           }\n           var intent = Intent().apply {\n               action = \"com.zjp.messengerservice\"\n               setPackage(\"com.zjp.androidacrossprocessesservice\")\n           }\n      var result = bindService(intent, conn, Context.BIND_AUTO_CREATE)\n   ```\n\n3. 服务端收到消息,通过Message.replyTo 给客户端发送消息\n   \n   ```kotlin\n   var serviceHandler = object : Handler(Looper.getMainLooper()) {\n           override fun handleMessage(msg: Message) {\n               super.handleMessage(msg)\n               when (msg.what) {\n                   0x110 -> {\n                       LogUtils.d(\"收到了客户端消息\")\n                       msg.replyTo.send(Message().apply {\n                           what = 0x110\n                       })\n                   }\n               }\n   \n           }\n       }\n   var messenger = Messenger(serviceHandler)\n   ```\n\n## AIDL\n\n1. 创建AIDL文件：\n   \n   > 通过Android Studio File -> New ->AIDL ->AIDL File ,就可以创建一个AIDL文件。然后Rebuild Project ,Android Studio 就会自动在 build -> generated -> buildType -> out 目录下生成对应的 .java文件，里面就包含了后期我们用到的Stub类。\n\n2. 实现Stub 接口：\n   \n   ```java\n   var stub = object : Stub() {\n           override fun basicType(\n               anInt: Int,\n               aLong: Long,\n               aBoolean: Boolean,\n               aFloat: Float,\n               aDouble: Double,\n               aString: String?\n           ): String {\n   \n               return \"this data is from service\"\n           }\n       }\n   ```\n\n3. onBind 方法返回 stub，向客户端公开接口：\n   \n   ```java\n   override fun onBind(intent: Intent?): IBinder? {\n   \n           return stub.asBinder()\n       }\n   ```\n   \n   现在，`binder` 是 `Stub` 类的一个实例（一个 Binder），其定义了服务的远程过程调用 (RPC) 接口。在下一步中，我们会向客户端公开此实例，以便客户端能与服务进行交互。\n   \n   > - 默认情况下，RPC 调用是同步调用。如果您知道服务完成请求的时间不止几毫秒，则不应从 Activity 的**主线程**调用该服务，因为这可能会使应用挂起（Android 可能会显示“Application is Not Responding”对话框）— 通常，您应从客户端内的单独线程调用服务\n   > \n   > - 您引发的任何异常都不会回传给调用方。\n   \n   > AIDL 支持一下数据类型\n   > \n   > - Java基本数据类型 byte char short int long float double boolean\n   > \n   > - String\n   > \n   > - CharSequence\n   > \n   > - List List里面所有数据必须实现 Parcelable\n   > \n   > - Map Map里面所有数据必须实现 Parcelable\n\n4. Copy 服务端 aidl 文件夹到 客服端对应位置,客户端在 onServiceConnected() 回调中YourServiceInterface*.Stub.asInterface(service),以将返回的参数转换成 *YourServiceInterface* 类型。![](https://raw.githubusercontent.com/SkylineVagrancy/cloudimg/master/2022/02/15-11-16-01-screenshot-20220215-111420.png)\n   \n   ```java\n    var conn = object : ServiceConnection {\n               override fun onServiceConnected(name: ComponentName?, service: IBinder?) {\n                   var stub = IMyAidlInterface.Stub.asInterface(service)\n                   var result = stub.basicTypes(1, 1, false, 1.0f, 1.0, \"测试\")\n   \n               }\n   \n               override fun onServiceDisconnected(name: ComponentName?) {\n   \n               }\n    }\n   ```\n\n## 最后\n\n- **文件共享**：适用于 实时性要求不高，并发场景不多的情况，用法简单通用\n\n- **Bundle：** 适用于Android四大组件之间\n\n- **ContentProvider：** 适用于为其他客户端提供数据，不涉及双向通信\n\n- **AIDL：** 适用于大量复杂数据，有实时双向数据通讯\n\n- **Messenger：** AIDL的简化版本，适用于数据简单，数据交换不是那么频繁\n","tags":["Android"]},{"title":"Hello World","url":"/2022/01/19/hello-world/","content":"\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n```bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n```bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n```bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n```bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"},{"title":"WebSocket报文","url":"/2021/12/15/Websocket 连接过程报文/","content":"# Websocket 连接过程\n\n## 客户端请求报文\n\n    GET / HTTP/1.1\n    Upgrade: websocket\n    Connection: Upgrade\n    Host: example.com\n    Origin: http://example.com\n    Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==\n    Sec-WebSocket-Version: 13 \n\n### 与传统 HTTP 报文不同的地方：\n\n    Upgrade: websocket\n    Connection: Upgrade \n\n这两行表示发起的是 WebSocket 协议。\n\n    Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==\n    Sec-WebSocket-Version: 13\n\nSec-WebSocket-Key 是由浏览器随机生成的，提供基本的防护，防止恶意或者无意的连接。\n<!--more-->\n\n## 服务端响应报文 Header\n\n首先我们来看看服务端的响应报文：\n\n    HTTP/1.1 101 Switching Protocols\n    Upgrade: websocket\n    Connection: Upgrade\n    Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=\n    Sec-WebSocket-Protocol: chat \n\n1. 首先，101 状态码表示服务器已经理解了客户端的请求，并将通过 Upgrade 消息头通知客户端采用不同的协议来完成这个请求；\n2. 然后， Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key；\n3. 最后， Sec-WebSocket-Protocol 则是表示最终使用的协议。\n\n### Sec-WebSocket-Accept 的计算方法：\n\n1. 将 **Sec-WebSocket-Key** 跟 **258EAFA5-E914-47DA-95CA-C5AB0DC85B11** 拼接\n2. 通过 SHA1 计算出摘要，并转成 base64 字符串。\n","tags":["WebSocket"]},{"title":"Ubuntu下载Android AOSP源码","url":"/2021/10/20/AOSP源码下载/","content":"\n\n由于Android源码过于庞大，普通的代码管理方式不太适用，谷歌就开发了repo工具，专门用于管理Android源码。repo，其实是谷歌使用Python 对Git封装的一个工具而已，本质还是Git，所以我们首先要安装Git和Python。\n\n## 下载repo工具\n\n### 安装Git并设置邮箱和用户名\n\n```bash\nsudo apt-get install git\ngit config --global user.email “usergmail@gmail.com”\ngit config --global user.name “username”\n```\n\n### 安装Python\n\n```bash\nsudo apt-get install python\n```\n\n<!--more-->\n\n### 安装curl库\n\n```bash\nsudo apt-get install curl\n```\n\n### 下载repo并设置权限\n\n```bash\nmkdir ~/bin\nPATH=~/bin:$PATH\ncurl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\n#curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo > ~/bin/repo  #国内源，无需翻墙\nchmod a+x ~/bin/repo  #设置权限\n```\n\n## 下载源码\n\n```bash\nmkdir aosp\ncd aosp\n```\n\n### 初始化指定版本\n\n```bash\nrepo init -u https://android.googlesource.com/platform/manifest -b android-9.0.0_r1\n```\n\n> Android版本号查询：[Android 所有版本号](https://android.googlesource.com/platform/manifest/+refs)\n\n如果网络不能翻墙，建议使用清华镜像源[清华源镜像](https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/) 。如果知识阅读，建议使用清华源，如果想编译并在虚拟机上运行，建议翻墙下载谷歌AOSP。\n\n### 下载源码\n\n在初始好了指定版本之后，执行下面的命令就会自动下载源码，我们就只需要静静的等待下载完成。\n\n```bash\nrepo sync\n```\n\n![screenshot-20220114-163417.png](https://raw.githubusercontent.com/SkylineVagrancy/cloudimg/master/2022/01/14-16-34-35-screenshot-20220114-163417.png)\n\n\n\n**下载完成后大概100G左右，但是实际下载过程中会产生很多零时文件，最好预留200G的硬盘空间**\n","tags":["Android"]},{"title":"MarkDown速记","url":"/2021/10/10/markdown/","content":"\n最近准备弄个自己的博客，记录整理一下自己的学习过程。MarkDown作为一种标记语言，简单易上手，而且比较流行的博客都对MarkDown有很好的支持，所以记录一下MarkDown的简单用户，方便在以后的学习中，能刚快的上手。\n\n# 设置头部\n\n```bash\n# Header 1\n## Header 2\n### Header 3\n#### Header 4\n##### Header 5\n###### Header 6\n```\n\n<font color=#ff0000 size=3>效果</font>\n\n## Header 2\n\n### Header 3\n\n#### Header 4\n\n##### Header 5\n\n###### Header 6\n\n<!--more-->\n\n# 无序列表（<font color=#ff0000 size=3>注意缩进</font>）\n\n```bash\n*  第一列\n * 第二列\n * 第三列\n  * 第四列\n```\n\n<font color=#ff0000 size=3>效果</font>\n\n* 第一列\n* 第二列\n* 第三列\n  * 第四列\n\n# 有序列表\n\n```\n1. 第一列\n2. 第二列\n3. 第三列\n```\n\n### <font color=#ff0000 size=3>效果</font>\n\n1. 第一列\n2. 第二列\n3. 第三列\n4. 第四列\n\n# 引用\n\n```\n> 第一列\n> 第二列\n> 第三列\n```\n\n### <font color=#ff0000 size=3>引用效果</font>\n\n> 第一列    \n> 第二列    \n> 第三列    \n\n# 嵌套列表\n\n```\n- 列表1\n    + 列表2\n    + 列表3\n        + 列表8\n- 列表4\n    +  列表5\n    +  列表6\n```\n\n### <font color=#ff0000 size=3>嵌套列表效果</font>\n\n- 列表1\n  + 列表2\n  + 列表3\n    + 列表8\n- 列表4\n  + 列表5\n  + 列表6\n\n# 文字链接\n\n```\n[百度一下](https://www.baidu.com \"百度一下\")\n```\n\n### <font color=#ff0000 size=3>文字链接效果</font>\n\n[百度一下](https://www.baidu.com \"百度一下\")\n\n> 前面的百度一下表示展示文字    \n> 后面的百度一下指当鼠标在文字上面的时候显示的内容 \n\n# 图片链接\n\n```\n![测试](http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png \"GitHub Mark\")\n```\n\n### <font color=#ff0000 size=3>图片链接效果</font>\n\n![测试](http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png \"GitHub Mark\")\n\n> 前面的测试指图片的名称  \n> 后面的github mark指鼠标放在图片上展示的内容\n\n# 自动链接\n\n```\n<854350705@qq.com>\n<https:www.baidu.com>\n```\n\n### <font color=#ff0000 size=3>自动链接效果</font>\n\n<854350705@qq.com>    \n<https:www.baidu.com>\n\n# 代码\n\n```\n用``` ```包裹\n或者每行文字4个空格或者1个TAB\n```\n\n### <font color=#ff0000 size=3>代码效果</font>\n\n```java\nString a=\"a\";\nString b = \"b\";\npriintln(a+b);\n```\n\n    String a=\"a\";\n    String a=\"a\";\n    String a=\"a\";\n\n#注释\n\n```\n<!-- 注释 -->\n```\n\n<!-- 注释 -->\n\n# 转义字符\n\n```\n\\\\ 反斜杠\n\\` 反引号\n\\* 星号\n\\_ 下划线\n\\{\\} 大括号\n\\[\\] 中括号\n\\(\\) 小括号\n\\# 井号\n\\+ 加号\n\\- 减号\n\\. 英文句号\n\\! 感叹号\n```\n\n### <font color=#ff0000 size=3>转义效果（每个字符前添加\\）</font>\n\n\\\\ 反斜杠\n\n\\` 反引号\n\n\\* 星号\n\n\\_ 下划线\n\n\\{\\} 大括号\n\n\\[\\] 中括号\n\n\\(\\) 小括号\n\n\\# 井号\n\n\\+ 加号\n\n\\- 减号\n\n\\. 英文句号\n\n\\! 感叹号\n\n# 表格\n\n```\n| 列1        | 列2           |列3 |\n| ------------- |:-------------:| -----:|\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      | centered      |   $12 |\n| zebra stripes | are neat      |    $1 |\n```\n\n### <font color=#ff0000 size=3>表格效果</font>\n\n| 列1            | 列2            | 列3    |\n| ------------- |:-------------:| -----:|\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      | centered      | $12   |\n| zebra stripes | are neat      | $1    |\n\n# 设置字体大小颜色\n\n```\n### <font color=#ff0000 face=\"微软雅黑\" size=12> 表格效果</font>\n```\n\n### <font color=#ff0000 face=\"微软雅黑\" size=3> 设置字体大小颜色效果</font>\n\n# 行内标签\n\n```\n快捷键 `Ctrl + D` 来收藏本页\n```\n\n### <font color=#ff0000 size=3> 行内标签效果</font>\n\n快捷键 `Ctrl + D` 来收藏本页\n\n#html标签\n\n<table>\n    <tr>\n        <th rowspan=\"2\">值班人员</th>\n        <th>星期一</th>\n        <th>星期二</th>\n        <th>星期三</th>\n    </tr>\n    <tr>\n        <td>李强</td>\n        <td>张明</td>\n        <td>王平</td>\n    </tr>\n</table>\n\n#参考式链接\n\n```\n我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3]\n[Leanote 笔记][2]是一个不错的[网站][]。\n[1]:http://www.google.com \"Google\"\n[2]:http://www.leanote.com \"Leanote\"\n[3]:http://http://blog.leanote.com/freewalk \"梵居闹市\"\n[网站]:http://http://blog.leanote.com/freewalk\n```\n\n我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3]\n[Leanote 笔记][2]是一个不错的[网站][]。\n[1]:http://www.google.com \"Google\"\n[2]:http://www.leanote.com \"Leanote\"\n[3]:http://http://blog.leanote.com/freewalk \"梵居闹市\"\n[网站]:http://http://blog.leanote.com/freewalk\n\n#包含段落的列表\n\n> 必须缩进4个空格或者1个TAB\n\n<span id = \"jump\">跳转到这里：</span>\n\n[说明文字](#jump)\n\n# 文字加粗\n\n```\n **加粗内容**\n```\n\n **加粗内容**\n\n# 文字斜体\n\n```\n_斜体_\n```\n\n _斜体_\n","tags":["MarkDown","速记"]},{"title":"Git速记","url":"/2021/08/10/git/","content":"\n### 配置操作\n\n全局配置\n\n`git config --global user.name '您的名字' `\n\n`git config --global user.email '您的邮箱'`\n\n当前仓库配置\n\n`git config --local user.name '您的名字'`\n\n`git config --local user.email '您的邮箱'`\n\n查看Global配置\n`git config --local --list`\n\n删除Global 配置\n\n`git config --unset --global 要删除的配置项`\n\n<!--more-->\n\n删除当前仓库配置\n\n`git config --unset --local 要删除的配置项`\n\n### 本地操作\n\n查看变更\n\n`git status`\n\n将当前目录及其子目录的所有变更保存到暂存区\n\n`git add .`\n\n将仓库内所有变更都加入到暂存区\n\n`git add -A`\n\n将制定文件添加到暂存区\n\n`git add 文件1 文件2 文件3`\n\n比较工作区和暂存区的差异\n\n`git diff`\n\n比较某文件工作区和暂存区的所有差异\n\n`git diff 文件1`\n\n比较暂存区和  **HEAD**  的所有差异\n\n`git diff --cache`\n\n比较某文件暂存区和  **HEAD**  的所有差异\n\n`git diff --cache 文件`\n\n比较某文件工作区和 **HEAD** 的差异\n\n`git diff HEAD 文件`\n\n创建commit\n\n`git commit -m '描述'`\n\n将工作区指定文件恢复和暂存区一致\n\n`git checkout 文件1 文件2 文件3`\n\n将暂存区指定文件恢复和 **HEAD** 一致\n\n`git reset 文件1 文件2 文件3`\n\n将工作区、暂存区所有文件恢复成和 **HEAD** 一致\n\n`git reset --hard`\n\n用 **difftool** 比较任意两个 **commit** 的差异 \n\n`git difftool 提交1 提交2`\n\n查看那些文件没有被git 管控\n\n`git ls-files --others`\n\n将未处理完的变更先保存到 **stash** 中\n\n`git stash`\n\n临时任务处理完继续之前的工作\n\n`pop 不保留 stash`\n\n`apply 保留stash`\n\n`git stash pop`\n\n`git stash apply`\n\n查看所有stash\n\n`git stash list`\n\n取回某次stash 的变更\n\n`git stash pop stash@{数字n}`\n\n修改最后一次的commit 的错误\n\n1. 修改有bug 文件\n2. git add .\n3. git commit –amend –no-edit\n4. git push\n\n### 分支操作\n\n查看当前工作分支和本地分支\n\n`git branch -v`\n\n查看本地和远端分支\n\n`git branch -rv`\n\n切换到指定分支\n\n`git checkout 指定分支`\n\n基于当前分支创建新分支\n\n`git branch 新分支`\n\n基于指定分支创建新分支\n\n`git branch 新分支 指定分支`\n\n基于某个 commit 创建分支\n\n`git branch 新分支 某个commit的id`\n\n创建并切换 到新分支\n\n`git checkout -b 新分支`\n\n安全删除本地某分支\n\n`git branch -d 要删除的分支`\n\n强行删除本地某分支\n\n`git branch -D 要删除的分支`\n\n删除远端 origin 已不存在的本地分支\n\n`git remote prune orgin`\n\n将A分支合并到当前分支\n\n`git merge A分支`\n\n将A分支合并到B分支\n\n`git merge A B`\n\n将当前分支基于B分支坐rebase,以便将B分支合并到当前分支\n\n`git rebase B分支`\n\n将A分支基于B分支坐rebase,以便将B分支合入到A分支\n\n`git rebase B分支 A分支`\n\n### 变更历史\n\n当前分支各个commit 用一行显示\n\n`git log --oneline`\n\n显示就近的N个commit\n\n`git log n`\n\n查看所有涉及某文件的commit\n\n`git log 文件`\n\n某文件最后修改对应的commit 以及作者\n\n`git blame 文件`\n\n### 标签查看\n\n查看所有标签\n\n`git tag`\n\n新建标签\n\n`git tag v1.0`\n\n新建带备注标签\n\n`git tag v1.0 -m '备注'`\n\n给指定的commit 打标签\n\n`git tag 标签 提交ID`\n\n推送一个本地标签\n\n`git push origin 标签`\n\n推送全部未推送的本地标签\n\n`git push origin --tags`\n\n删除一个本地标签\n\n`git tag -d 标签`\n\n删除一个远端标签\n\n`git push origin:refs/tags/标签`\n\n### 远端交互\n\n查看所有远端仓库\n\n`git remote -v`\n\n添加远端仓库\n\n`git remote add origin 远端仓库URL`\n\n删除远端仓库\n\n```java\ngit remote remove 远端仓库名\n```\n\n重命名远端仓库\n\n`git remote rename 旧名称 新名称`\n\n将远端所有分支和标签的变更拉倒本地\n\n`git fetch remote`\n\n把远端分支的变更拉倒本地，且 merge 到本地分支\n\n`git pull origin 分支名`\n\n将本地分支 push 到远端\n\n`git push origin 分支名`\n\n删除远端分支\n\n`git push remote --delete 远端分支`\n\n`git push remote:远端分支名`\n\n![git](https://raw.githubusercontent.com/SkylineVagrancy/cloudimg/master/2022/02/16-11-38-22-git%E9%80%9F%E8%AE%B0.jpeg)\n","tags":["Git"]}]